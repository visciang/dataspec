searchData={"items":[{"type":"module","title":"DataSpecs","doc":"DataSpecs.","ref":"DataSpecs.html"},{"type":"macro","title":"DataSpecs.__using__/1","doc":"Defines a cast helper function in a struct module.\n\n```elixir\ndefmodule Person do\n  use DataSpecs\n\n  @enforce_keys [:name, :surname]\n  defstruct @enforce_keys ++ [:birth_date]\n\n  @type t :: %__MODULE__{\n              name: String.t(),\n              surname: String.t(),\n              birth_date: nil | Date.t(),\n            }\nend\n```\n\n```elixir\nPerson.cast(%{\"name\" => \"John\", surname => \"Smith\", \"birth_date\": \"1980-12-31\"})\n\n%Person{\n  name: \"John\",\n  surname: \"Smith\",\n  birth_date: ~D[1980-12-31]\n}\n```\n\nequivalent to\n\n```elixir\nDataSpecs.cast(%{\"name\" => \"John\", surname => \"Smith\"}, {Person, :t})\n```","ref":"DataSpecs.html#__using__/1"},{"type":"function","title":"DataSpecs.cast/4","doc":"Cast a value that should conform to a typespec.\n\n> ##","ref":"DataSpecs.html#cast/4"},{"type":"function","title":"Info {: .info} - DataSpecs.cast/4","doc":">\n> `custom_type_casts` defaults to `DataSpecs.Cast.Extra.type_casts/0`.\n> This will by default map types such as `t:Date.t/0`, `t:DateTime.t/0`, `t:MapSet.t/0`, ...\n> as describer in the module documentation.","ref":"DataSpecs.html#cast/4-info-info"},{"type":"module","title":"DataSpecs.Cast.Builtin","doc":"Erlang builtin types cast.","ref":"DataSpecs.Cast.Builtin.html"},{"type":"function","title":"DataSpecs.Cast.Builtin.any/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#any/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.arity/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#arity/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.atom/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#atom/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.binary/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#binary/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.binary/5","doc":"","ref":"DataSpecs.Cast.Builtin.html#binary/5"},{"type":"function","title":"DataSpecs.Cast.Builtin.bitstring/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#bitstring/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.boolean/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#boolean/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.byte/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#byte/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.char/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#char/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.empty_list/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#empty_list/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.empty_map/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#empty_map/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.float/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#float/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.integer/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#integer/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.list/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#list/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.map_field_optional/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#map_field_optional/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.map_field_required/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#map_field_required/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.neg_integer/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#neg_integer/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.non_neg_integer/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#non_neg_integer/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.nonempty_list/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#nonempty_list/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.number/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#number/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.pid/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#pid/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.pos_integer/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#pos_integer/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.range/5","doc":"","ref":"DataSpecs.Cast.Builtin.html#range/5"},{"type":"function","title":"DataSpecs.Cast.Builtin.reference/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#reference/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.tuple/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#tuple/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.tuple_any/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#tuple_any/3"},{"type":"function","title":"DataSpecs.Cast.Builtin.union/3","doc":"","ref":"DataSpecs.Cast.Builtin.html#union/3"},{"type":"type","title":"DataSpecs.Cast.Builtin.map_field_res/0","doc":"","ref":"DataSpecs.Cast.Builtin.html#t:map_field_res/0"},{"type":"module","title":"DataSpecs.Cast.Extra","doc":"Elixir types cast.","ref":"DataSpecs.Cast.Extra.html"},{"type":"function","title":"DataSpecs.Cast.Extra.isodate/3","doc":"Type cast for Elixir Date.t().\nExpect an iso8601 date string value, returns a Date.t().","ref":"DataSpecs.Cast.Extra.html#isodate/3"},{"type":"function","title":"DataSpecs.Cast.Extra.isodatetime/3","doc":"Type cast for Elixir DateTime.t().\nExpect an iso8601 datetime string value, returns a DateTime.t().","ref":"DataSpecs.Cast.Extra.html#isodatetime/3"},{"type":"function","title":"DataSpecs.Cast.Extra.mapset/3","doc":"Type cast for Elixir MapSet.t(T).\nExpect an Enumarable value of type T, returns a MapSet.t(T).","ref":"DataSpecs.Cast.Extra.html#mapset/3"},{"type":"function","title":"DataSpecs.Cast.Extra.type_casts/0","doc":"All extra types casts.\n\nMyData.cast(value, DataSpecs.Cast.Extra.type_cast())","ref":"DataSpecs.Cast.Extra.html#type_casts/0"},{"type":"module","title":"DataSpecs.Plug.Cast","doc":"DataSpecs Plug.\n\nNOTE: this module is available if you include the optional dependency `plug`.\n\nThis module can be used to plug a \"Jason.decode! -> DataSpecs.cast\" pipeline in your routes.\n\nFor example:\n\n```elixir\ndefmodule Api.Router.Something do\n  use Plug.Router\n  import DataSpecs.Plug.Cast, only: [typeref: 2, value: 1]\n\n  plug :match\n  plug DataSpecs.Plug.Cast\n  plug :dispatch\n\n  post \"/foo\", typeref(Api.Model.Foo, :t) do\n    %Api.Model.Foo{...} = value(conn)\n    ...\n  end\nend\n\ndefmodule Api.Model.Foo do\n  defmodule Bar do\n    @enforce_keys [:b1]\n    defstruct @enforce_keys ++ [:b2]\n\n    @type t :: %__MODULE__{\n            b1: number(),\n            b2: nil | String.t()\n          }\n  end\n\n  @enforce_keys [:a, :bars]\n  defstruct @enforce_keys\n\n  @type t :: %__MODULE__{\n          a: non_neg_integer(),\n          bars: [Bar.t()]\n        }\nend\n```","ref":"DataSpecs.Plug.Cast.html"},{"type":"function","title":"DataSpecs.Plug.Cast.call/2","doc":"","ref":"DataSpecs.Plug.Cast.html#call/2"},{"type":"function","title":"DataSpecs.Plug.Cast.init/1","doc":"","ref":"DataSpecs.Plug.Cast.html#init/1"},{"type":"function","title":"DataSpecs.Plug.Cast.typeref/2","doc":"Declare the type the body of a route should conform\n\nFor example:\n\n```elixir\npost \"/foo\", typeref(Model.Foo) do\n  ...\nend\n```","ref":"DataSpecs.Plug.Cast.html#typeref/2"},{"type":"function","title":"DataSpecs.Plug.Cast.value/1","doc":"Get the casted value.\n\nFor example:\n\n```elixir\npost \"/foo\", typeref(Api.Model.Foo, :t) do\n  %Api.Model.Foo{...} = value(conn)\n  ...\nend\n```","ref":"DataSpecs.Plug.Cast.html#value/1"},{"type":"module","title":"DataSpecs.Schema","doc":"DataSpec Schema.","ref":"DataSpecs.Schema.html"},{"type":"function","title":"DataSpecs.Schema.load/1","doc":"Load all the typespec defined in `module` into `t:DataSpecs.Schema.Type.t/0` structs.","ref":"DataSpecs.Schema.html#load/1"},{"type":"module","title":"DataSpecs.Schema.Formatter","doc":"Formatter.","ref":"DataSpecs.Schema.Formatter.html"},{"type":"function","title":"DataSpecs.Schema.Formatter.to_typespec_string/2","doc":"Convert a schema to its typespec representation.","ref":"DataSpecs.Schema.Formatter.html#to_typespec_string/2"},{"type":"module","title":"DataSpecs.Schema.Type","doc":"Type specifications' schema.\n\nRef [Elixir Typespecs](https://hexdocs.pm/elixir/typespecs.html)","ref":"DataSpecs.Schema.Type.html"},{"type":"function","title":"DataSpecs.Schema.Type.format_typeref/1","doc":"","ref":"DataSpecs.Schema.Type.html#format_typeref/1"},{"type":"type","title":"DataSpecs.Schema.Type.t/0","doc":"","ref":"DataSpecs.Schema.Type.html#t:t/0"},{"type":"type","title":"DataSpecs.Schema.Type.type/0","doc":"","ref":"DataSpecs.Schema.Type.html#t:type/0"},{"type":"type","title":"DataSpecs.Schema.Type.visibility/0","doc":"","ref":"DataSpecs.Schema.Type.html#t:visibility/0"},{"type":"module","title":"DataSpecs.Schema.Type.Bitstring","doc":"Bit string.","ref":"DataSpecs.Schema.Type.Bitstring.html"},{"type":"type","title":"DataSpecs.Schema.Type.Bitstring.t/0","doc":"","ref":"DataSpecs.Schema.Type.Bitstring.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Builtin","doc":"A builtin type.","ref":"DataSpecs.Schema.Type.Builtin.html"},{"type":"type","title":"DataSpecs.Schema.Type.Builtin.t/0","doc":"","ref":"DataSpecs.Schema.Type.Builtin.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.List","doc":"List.","ref":"DataSpecs.Schema.Type.List.html"},{"type":"type","title":"DataSpecs.Schema.Type.List.cardinality/0","doc":"","ref":"DataSpecs.Schema.Type.List.html#t:cardinality/0"},{"type":"type","title":"DataSpecs.Schema.Type.List.t/0","doc":"","ref":"DataSpecs.Schema.Type.List.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Literal","doc":"A literal type.","ref":"DataSpecs.Schema.Type.Literal.html"},{"type":"module","title":"DataSpecs.Schema.Type.Literal.Atom","doc":"Literal atom.","ref":"DataSpecs.Schema.Type.Literal.Atom.html"},{"type":"type","title":"DataSpecs.Schema.Type.Literal.Atom.t/0","doc":"","ref":"DataSpecs.Schema.Type.Literal.Atom.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Literal.Integer","doc":"Literal integer.","ref":"DataSpecs.Schema.Type.Literal.Integer.html"},{"type":"type","title":"DataSpecs.Schema.Type.Literal.Integer.t/0","doc":"","ref":"DataSpecs.Schema.Type.Literal.Integer.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Map","doc":"Map.","ref":"DataSpecs.Schema.Type.Map.html"},{"type":"type","title":"DataSpecs.Schema.Type.Map.kv/0","doc":"","ref":"DataSpecs.Schema.Type.Map.html#t:kv/0"},{"type":"type","title":"DataSpecs.Schema.Type.Map.t/0","doc":"","ref":"DataSpecs.Schema.Type.Map.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Map.Key","doc":"A map key.","ref":"DataSpecs.Schema.Type.Map.Key.html"},{"type":"type","title":"DataSpecs.Schema.Type.Map.Key.t/0","doc":"","ref":"DataSpecs.Schema.Type.Map.Key.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Range","doc":"Range.","ref":"DataSpecs.Schema.Type.Range.html"},{"type":"type","title":"DataSpecs.Schema.Type.Range.t/0","doc":"","ref":"DataSpecs.Schema.Type.Range.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Ref","doc":"Type reference (remote/user types).","ref":"DataSpecs.Schema.Type.Ref.html"},{"type":"type","title":"DataSpecs.Schema.Type.Ref.t/0","doc":"","ref":"DataSpecs.Schema.Type.Ref.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Tuple","doc":"Tuple.","ref":"DataSpecs.Schema.Type.Tuple.html"},{"type":"type","title":"DataSpecs.Schema.Type.Tuple.cardinality/0","doc":"","ref":"DataSpecs.Schema.Type.Tuple.html#t:cardinality/0"},{"type":"type","title":"DataSpecs.Schema.Type.Tuple.t/0","doc":"","ref":"DataSpecs.Schema.Type.Tuple.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Union","doc":"Union.","ref":"DataSpecs.Schema.Type.Union.html"},{"type":"type","title":"DataSpecs.Schema.Type.Union.t/0","doc":"","ref":"DataSpecs.Schema.Type.Union.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Unsupported","doc":"Unsupported type specs.","ref":"DataSpecs.Schema.Type.Unsupported.html"},{"type":"type","title":"DataSpecs.Schema.Type.Unsupported.t/0","doc":"","ref":"DataSpecs.Schema.Type.Unsupported.html#t:t/0"},{"type":"module","title":"DataSpecs.Schema.Type.Var","doc":"Type variable.","ref":"DataSpecs.Schema.Type.Var.html"},{"type":"type","title":"DataSpecs.Schema.Type.Var.t/0","doc":"","ref":"DataSpecs.Schema.Type.Var.html#t:t/0"},{"type":"module","title":"DataSpecs.Types","doc":"Common types.","ref":"DataSpecs.Types.html"},{"type":"type","title":"DataSpecs.Types.cast_result/1","doc":"","ref":"DataSpecs.Types.html#t:cast_result/1"},{"type":"type","title":"DataSpecs.Types.custom_type_casts/0","doc":"","ref":"DataSpecs.Types.html#t:custom_type_casts/0"},{"type":"type","title":"DataSpecs.Types.mt/0","doc":"","ref":"DataSpecs.Types.html#t:mt/0"},{"type":"type","title":"DataSpecs.Types.mta/0","doc":"","ref":"DataSpecs.Types.html#t:mta/0"},{"type":"type","title":"DataSpecs.Types.reason/0","doc":"","ref":"DataSpecs.Types.html#t:reason/0"},{"type":"type","title":"DataSpecs.Types.type_cast_fun/0","doc":"","ref":"DataSpecs.Types.html#t:type_cast_fun/0"},{"type":"type","title":"DataSpecs.Types.type_id/0","doc":"","ref":"DataSpecs.Types.html#t:type_id/0"},{"type":"type","title":"DataSpecs.Types.value/0","doc":"","ref":"DataSpecs.Types.html#t:value/0"},{"type":"task","title":"mix dataspecs.schema.dump","doc":"Dump a type schema.\n\n    mix dataspecs.schema.dump MyModule","ref":"Mix.Tasks.Dataspecs.Schema.Dump.html"},{"type":"extras","title":"DataSpecs","doc":"# DataSpecs\n\n[![.github/workflows/ci.yml](https://github.com/visciang/dataspecs/actions/workflows/ci.yml/badge.svg)](https://github.com/visciang/dataspecs/actions/workflows/ci.yml)\n[![Docs](https://img.shields.io/badge/docs-latest-green.svg)](https://visciang.github.io/dataspecs/readme.html)\n[![Coverage Status](https://coveralls.io/repos/github/visciang/dataspecs/badge.svg?branch=main)](https://coveralls.io/github/visciang/dataspecs?branch=main)\n\nTypespec based data cast and validator (inspired by [forma](https://github.com/soundtrackyourbrand/forma)).\n\nDataSpecs **cast** elixir data into a more structured form\nby trying to map it to conform to a [typespec](https://hexdocs.pm/elixir/typespecs.html).\n\nIt support the following typespec specifications:\n- basic types\n- literal types\n- built-in types\n- range types\n- union types\n- parametrized types\n- map (and elixir struct) types\n- remote types\n- user defined types\n\nThe main use cases are about elixir data validatation against a typespec or\ninterfacing with external data sources that provide you data as JSON or MessagePack,\nbut that you wish to validate and transform into either proper structs or\nricher data types without a native JSON representation (such as dates or sets).","ref":"readme.html"},{"type":"extras","title":"Usage - DataSpecs","doc":"Given the following `Person` struct specification\n\n```elixir\ndefmodule Person do\n  use DataSpecs\n\n  @enforce_keys [:name, :surname]\n  defstruct @enforce_keys ++ [:gender, :address, :birth_date]\n\n  @type t :: %__MODULE__{\n               name: String.t(),\n               surname: String.t(),\n               gender: option(:male | :female | :other),\n               address: option([Address.t(), ...]),\n               birth_date: option(Date.t())\n             }\n\n  @type option(x) :: nil | x\nend\n\ndefmodule Address do\n  @enforce_keys [:streetname, :streenumber, :postcode, :town]\n  defstruct @enforce_keys\n\n  @type t :: %__MODULE__{\n               streetname: String.t(),\n               streenumber: String.t(),\n               postcode: String.t(),\n               town: String.t()\n             }\nend\n```\n\nwe can cast a JSON object encoding an instance of a `Person` with:\n\n```elixir\n~s/{\n  \"name\": \"Joe\",\n  \"surname\": \"Smith\",\n  \"gender\": \"male\",\n  \"birth_date\": \"1980-12-31\",\n  \"address\": [{\n    \"streetname\": \"High Street\",\n    \"streenumber\": \"3a\",\n    \"postcode\": \"SO31 4NG\",\n    \"town\": \"Hedge End, Southampton\"\n  }]\n}/\n|> Jason.decode!()\n|> Person.cast()\n\n# => %Person{\n#      address: [\n#        %Address{\n#          postcode: \"SO31 4NG\",\n#          streenumber: \"3a\",\n#          streetname: \"High Street\",\n#          town: \"Hedge End, Southampton\"\n#        }\n#      ],\n#      birth_date: ~D[1980-12-31],\n#      gender: :male,\n#      name: \"Joe\",\n#      surname: \"Smith\"\n#    }\n```\n\nDataSpecs tries to figure out how to translate its input to an elixir datatype using the typespec as \"type schema\".\n\nScalar types (such as booleans, integers, etc.) and some composite types\n(such as lists, plain maps), can be simply mapped one to one after validation\nwithout any additional transformation. \n\nHowever, not all Elixir types have natural representations in JSON-like data (for example atoms and dates) or don't want to expose their internals (opaque types).\n\nRefer to the library test suite for more examples.","ref":"readme.html#usage"},{"type":"extras","title":"Installation - DataSpecs","doc":"```elixir\ndef deps do\n  [\n    {:dataspecs, \"~> xxx\"}\n  ]\nend\n```\n\nTypespecs should be included in the compiled ebin.\n\nSet the `:strip_beams` option to `false` when compiling your project with mix\nrelease or mix escript.\n\n```elixir\ndef project do\n  [\n    app: :my_app,\n    deps: deps(),\n    releases: [\n      my_app: [strip_beams: false]\n    ],\n    ...\n  ]\nend\n\ndef project do\n  [\n    app: :my_script,\n    deps: deps(),\n    escript: [\n      strip_beams: false,\n      ...\n    ],\n    ...\n  ]\nend\n```","ref":"readme.html#installation"},{"type":"extras","title":"Type cast - DataSpecs","doc":"#","ref":"readme.html#type-cast"},{"type":"extras","title":"Builtin - DataSpecs","doc":"For reference, check the cast available under `DataSpecs.Cast.Builtin` and `DataSpecs.Cast.Extra`.\n\nThe modules `DataSpecs.Cast.Extra` provides pre-defined custom type cast for:\n- `t:DateTime.t/0`: cast iso datetime strings (ie: `2001-12-31 06:54:02Z` -> `~U[2001-12-31 06:54:02Z]`)\n- `t:Date.t/0`: cast iso date strings (ie: `2001-12-31` -> `~D[2022-06-03]`)\n- `t:MapSet.t/1`: cast lists of `T` into a `MapSet.t(T)` (ie: `[1, 2]` -> `#MapSet<[1, 2]>`)\n\n#","ref":"readme.html#builtin"},{"type":"extras","title":"Custom - DataSpecs","doc":"You can pass custom type casts along as an optional argument to the `DataSpecs.cast/4` function.\n\nThe type of the custom cast function is\n\n```elixir\n@type custom_type_cast_fun :: (value(), custom_type_casts(), [type_cast_fun()] -> value())\n```\n\nfor example a custom `t:MapSet.t/1` cast could be implement as:\n\n```elixir\ndef custom_mapset_cast(value, custom_type_casts, [type_cast_fun]) do\n  case Enumerable.impl_for(value) do\n    nil ->\n      {:error, [\"can't convert #{inspect(value)} to a MapSet.t/1, value not enumerable\"]}\n\n    _ ->\n      value\n      |> Enum.to_list()\n      |> DataSpecs.Cast.Builtin.list(custom_type_casts, [type_cast_fun])\n      |> case do\n        {:ok, casted_value} ->\n          {:ok, MapSet.new(casted_value)}\n\n        {:error, errors} ->\n          {:error, [\"can't convert #{inspect(value)} to a MapSet.t/1\", errors]}\n      end\n  end\nend\n```\n\nThe custom cast take the input value, check it's enumerable and then builds a `MapSet`\nover the items of the input value. It takes as argument a list of `t:DataSpecs.Types.type_cast_fun/0` associated\nwith the type parameters.\n\nFor example, let's say we have:\n\n```elixir\n@type my_set_of_integer :: MapSet.t(integer())\n```\n\nand an input value:\n\n\n```elixir\n1..10\n```\n\nthen the custom type cast function will be called with\n\n```elixir\ncustom_mapset_cast(1..10, custom_type_casts, [&DataSpecs.Cast.Builtin.integer/3])\n```","ref":"readme.html#custom"},{"type":"extras","title":"Validators - DataSpecs","doc":"Custom validation rules can be defined with a custom type cast.\n\nFor example let's say than we want to validate a field of type string to be in upcase form:\n\n```elixir\ndefmodule AStruct do\n  use DataSpecs\n\n  @enforce_keys [:field]\n  defstruct @enforce_keys\n\n  @type t :: %__MODULE__{\n               field: upcase_string()\n             }\n\n  @type upcase_string :: String.t()\n\n  def custom_field_cast(value, custom_type_casts, type_params_casts) do\n    with {:ok, value} <- DataSpecs.Cast.Builtin.binary(value, custom_type_casts, type_params_casts)\n         ^name <- String.upcase(name) do\n      {:ok, name}\n    else\n      {:error, errors} ->\n        {:error, [\"#{inspect(value)} is not an upcase string\", errors]}\n\n      false ->\n        {:error, [\"#{inspect(value)} is not an upcase string\"]}\n    end\n  end\nend\n\ncustom_type_casts = %{{AStruct, :upcase_string, 0} => &AStruct.custom_field_cast/3}\nAStruct.cast(%{field: \"AAA\"}, custom_type_casts)\n# => %AStruct{field: \"AAA\"}\n```","ref":"readme.html#validators"},{"type":"extras","title":"Type coercion - DataSpecs","doc":"The following types coercion are implicitly applied:\n\n#","ref":"readme.html#type-coercion"},{"type":"extras","title":"float() - DataSpecs","doc":"`integer() -> float()`\n\nExample:\n\n```elixir\n# ---\n1\n# to\n1.0\n```\n\n#","ref":"readme.html#float"},{"type":"extras","title":"tuple() - DataSpecs","doc":"`list() -> tuple()`\n\n```elixir\n@type t :: {atom(), integer()}\n\n# ---\n[:a, 1]\n# to\n{:a, 1}\n```\n\n#","ref":"readme.html#tuple"},{"type":"extras","title":"struct() - DataSpecs","doc":"`map() -> struct()`\n\nExample:\n\n```elixir\ndefmodule AStruct do\n  defstruct [:a, :b]\n\n  @type t :: %__MODULE__{\n               a: nil | binary(),\n               b: nil | binary()\n             }\n\n# ---\n%{a: \"1\", b: \"2\"}\n# to\n%AStruct{a: \"1\", b: \"2\"}\n```\n\n#","ref":"readme.html#struct"},{"type":"extras","title":"map / struct keys - DataSpecs","doc":"`map / struct binary() keys -> existing atom()`\n\nExample:\n\n```elixir\n\n@type a_map :: %{\n        a: binary,\n        b: binary\n      }\n\n# ---\n%{\"a\" => \"1\", \"b\" => \"2\"}\n# to\n%{a: \"1\", b: \"2\"}\n```\n\n#","ref":"readme.html#map-struct-keys"},{"type":"extras","title":"atom() - DataSpecs","doc":"`binary() -> existing atom()`\n\nExample:\n\n```elixir\n# ---\n\"bin\"\n# to\n:bin\n```","ref":"readme.html#atom"},{"type":"extras","title":"Plug - DataSpecs","doc":"`DataSpecs.Plug.Cast` provides a plug to \"Jason.decode! -> DataSpecs.cast\" in your routes:\n\n```elixir\ndefmodule Api.Router.Something do\n  use Plug.Router\n  import DataSpecs.Plug.Cast, only: [typeref: 2, value: 1]\n\n  plug :match\n  plug DataSpecs.Plug.Cast\n  plug :dispatch\n\n  post \"/foo\", typeref(Api.Model.Foo, :t) do\n    %Api.Model.Foo{...} = value(conn)\n    ...\n  end\nend\n```","ref":"readme.html#plug"},{"type":"extras","title":"Ecto embedded schema validation comparison - DataSpecs","doc":"https://github.com/visciang/example_validation","ref":"readme.html#ecto-embedded-schema-validation-comparison"}],"content_type":"text/markdown"}