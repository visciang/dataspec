searchNodes=[{"doc":"DataSpecs.","ref":"DataSpecs.html","title":"DataSpecs","type":"module"},{"doc":"Defines a cast helper function in a struct module. defmodule Person do use DataSpecs @enforce_keys [ :name , :surname ] defstruct @enforce_keys ++ [ :birth_date ] @type t :: % __MODULE__ { name : String . t ( ) , surname : String . t ( ) , birth_date : nil | Date . t ( ) , } end Person . cast ( %{ &quot;name&quot; =&gt; &quot;John&quot; , surname =&gt; &quot;Smith&quot; , &quot;birth_date&quot; : &quot;1980-12-31&quot; } ) % Person { name : &quot;John&quot; , surname : &quot;Smith&quot; , birth_date : ~D[1980-12-31] } equivalent to DataSpecs . cast ( %{ &quot;name&quot; =&gt; &quot;John&quot; , surname =&gt; &quot;Smith&quot; } , { Person , :t } )","ref":"DataSpecs.html#__using__/1","title":"DataSpecs.__using__/1","type":"macro"},{"doc":"Cast a value that should conform to a typespec. Info custom_type_casts defaults to DataSpecs.Cast.Extra.type_casts/0 . This will by default map types such as Date.t/0 , DateTime.t/0 , MapSet.t/0 , ... as describer in the module documentation.","ref":"DataSpecs.html#cast/4","title":"DataSpecs.cast/4","type":"function"},{"doc":"Erlang builtin types cast.","ref":"DataSpecs.Cast.Builtin.html","title":"DataSpecs.Cast.Builtin","type":"module"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#any/3","title":"DataSpecs.Cast.Builtin.any/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#arity/3","title":"DataSpecs.Cast.Builtin.arity/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#atom/3","title":"DataSpecs.Cast.Builtin.atom/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#binary/3","title":"DataSpecs.Cast.Builtin.binary/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#binary/5","title":"DataSpecs.Cast.Builtin.binary/5","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#bitstring/3","title":"DataSpecs.Cast.Builtin.bitstring/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#boolean/3","title":"DataSpecs.Cast.Builtin.boolean/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#byte/3","title":"DataSpecs.Cast.Builtin.byte/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#char/3","title":"DataSpecs.Cast.Builtin.char/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#empty_list/3","title":"DataSpecs.Cast.Builtin.empty_list/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#empty_map/3","title":"DataSpecs.Cast.Builtin.empty_map/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#float/3","title":"DataSpecs.Cast.Builtin.float/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#integer/3","title":"DataSpecs.Cast.Builtin.integer/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#list/3","title":"DataSpecs.Cast.Builtin.list/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#map_field_optional/3","title":"DataSpecs.Cast.Builtin.map_field_optional/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#map_field_required/3","title":"DataSpecs.Cast.Builtin.map_field_required/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#neg_integer/3","title":"DataSpecs.Cast.Builtin.neg_integer/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#non_neg_integer/3","title":"DataSpecs.Cast.Builtin.non_neg_integer/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#nonempty_list/3","title":"DataSpecs.Cast.Builtin.nonempty_list/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#number/3","title":"DataSpecs.Cast.Builtin.number/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#pid/3","title":"DataSpecs.Cast.Builtin.pid/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#pos_integer/3","title":"DataSpecs.Cast.Builtin.pos_integer/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#range/5","title":"DataSpecs.Cast.Builtin.range/5","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#reference/3","title":"DataSpecs.Cast.Builtin.reference/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#tuple/3","title":"DataSpecs.Cast.Builtin.tuple/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#tuple_any/3","title":"DataSpecs.Cast.Builtin.tuple_any/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#union/3","title":"DataSpecs.Cast.Builtin.union/3","type":"function"},{"doc":"","ref":"DataSpecs.Cast.Builtin.html#t:map_field_res/0","title":"DataSpecs.Cast.Builtin.map_field_res/0","type":"type"},{"doc":"Elixir types cast.","ref":"DataSpecs.Cast.Extra.html","title":"DataSpecs.Cast.Extra","type":"module"},{"doc":"Type cast for Elixir Date.t(). Expect an iso8601 date string value, returns a Date.t().","ref":"DataSpecs.Cast.Extra.html#isodate/3","title":"DataSpecs.Cast.Extra.isodate/3","type":"function"},{"doc":"Type cast for Elixir DateTime.t(). Expect an iso8601 datetime string value, returns a DateTime.t().","ref":"DataSpecs.Cast.Extra.html#isodatetime/3","title":"DataSpecs.Cast.Extra.isodatetime/3","type":"function"},{"doc":"Type cast for Elixir MapSet.t(T). Expect an Enumarable value of type T, returns a MapSet.t(T).","ref":"DataSpecs.Cast.Extra.html#mapset/3","title":"DataSpecs.Cast.Extra.mapset/3","type":"function"},{"doc":"All extra types casts. MyData.cast(value, DataSpecs.Cast.Extra.type_cast())","ref":"DataSpecs.Cast.Extra.html#type_casts/0","title":"DataSpecs.Cast.Extra.type_casts/0","type":"function"},{"doc":"DataSpecs Plug. NOTE: this module is available if you include the optional dependency plug . This module can be used to plug a &quot;Jason.decode! -&gt; DataSpecs.cast&quot; pipeline in your routes. For example: defmodule Api.Router.Something do use Plug.Router import DataSpecs.Plug.Cast , only : [ typeref : 2 , value : 1 ] plug :match plug DataSpecs.Plug.Cast plug :dispatch post &quot;/foo&quot; , typeref ( Api.Model.Foo , :t ) do % Api.Model.Foo { ... } = value ( conn ) ... end end defmodule Api.Model.Foo do defmodule Bar do @enforce_keys [ :b1 ] defstruct @enforce_keys ++ [ :b2 ] @type t :: % __MODULE__ { b1 : number ( ) , b2 : nil | String . t ( ) } end @enforce_keys [ :a , :bars ] defstruct @enforce_keys @type t :: % __MODULE__ { a : non_neg_integer ( ) , bars : [ Bar . t ( ) ] } end","ref":"DataSpecs.Plug.Cast.html","title":"DataSpecs.Plug.Cast","type":"module"},{"doc":"Callback implementation for Plug.call/2 .","ref":"DataSpecs.Plug.Cast.html#call/2","title":"DataSpecs.Plug.Cast.call/2","type":"function"},{"doc":"Callback implementation for Plug.init/1 .","ref":"DataSpecs.Plug.Cast.html#init/1","title":"DataSpecs.Plug.Cast.init/1","type":"function"},{"doc":"Declare the type the body of a route should conform For example: post &quot;/foo&quot; , typeref ( Model.Foo ) do ... end","ref":"DataSpecs.Plug.Cast.html#typeref/2","title":"DataSpecs.Plug.Cast.typeref/2","type":"function"},{"doc":"Get the casted value. For example: post &quot;/foo&quot; , typeref ( Api.Model.Foo , :t ) do % Api.Model.Foo { ... } = value ( conn ) ... end","ref":"DataSpecs.Plug.Cast.html#value/1","title":"DataSpecs.Plug.Cast.value/1","type":"function"},{"doc":"DataSpec Schema.","ref":"DataSpecs.Schema.html","title":"DataSpecs.Schema","type":"module"},{"doc":"Load all the typespec defined in module into DataSpecs.Schema.Type.t/0 structs.","ref":"DataSpecs.Schema.html#load/1","title":"DataSpecs.Schema.load/1","type":"function"},{"doc":"Formatter.","ref":"DataSpecs.Schema.Formatter.html","title":"DataSpecs.Schema.Formatter","type":"module"},{"doc":"Convert a schema to its typespec representation.","ref":"DataSpecs.Schema.Formatter.html#to_typespec_string/2","title":"DataSpecs.Schema.Formatter.to_typespec_string/2","type":"function"},{"doc":"Type specifications' schema. Ref Elixir Typespecs","ref":"DataSpecs.Schema.Type.html","title":"DataSpecs.Schema.Type","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.html#format_typeref/1","title":"DataSpecs.Schema.Type.format_typeref/1","type":"function"},{"doc":"","ref":"DataSpecs.Schema.Type.html#t:t/0","title":"DataSpecs.Schema.Type.t/0","type":"type"},{"doc":"","ref":"DataSpecs.Schema.Type.html#t:type/0","title":"DataSpecs.Schema.Type.type/0","type":"type"},{"doc":"","ref":"DataSpecs.Schema.Type.html#t:visibility/0","title":"DataSpecs.Schema.Type.visibility/0","type":"type"},{"doc":"Bit string.","ref":"DataSpecs.Schema.Type.Bitstring.html","title":"DataSpecs.Schema.Type.Bitstring","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Bitstring.html#t:t/0","title":"DataSpecs.Schema.Type.Bitstring.t/0","type":"type"},{"doc":"A builtin type.","ref":"DataSpecs.Schema.Type.Builtin.html","title":"DataSpecs.Schema.Type.Builtin","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Builtin.html#t:t/0","title":"DataSpecs.Schema.Type.Builtin.t/0","type":"type"},{"doc":"List.","ref":"DataSpecs.Schema.Type.List.html","title":"DataSpecs.Schema.Type.List","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.List.html#t:cardinality/0","title":"DataSpecs.Schema.Type.List.cardinality/0","type":"type"},{"doc":"","ref":"DataSpecs.Schema.Type.List.html#t:t/0","title":"DataSpecs.Schema.Type.List.t/0","type":"type"},{"doc":"A literal type.","ref":"DataSpecs.Schema.Type.Literal.html","title":"DataSpecs.Schema.Type.Literal","type":"module"},{"doc":"Literal atom.","ref":"DataSpecs.Schema.Type.Literal.Atom.html","title":"DataSpecs.Schema.Type.Literal.Atom","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Literal.Atom.html#t:t/0","title":"DataSpecs.Schema.Type.Literal.Atom.t/0","type":"type"},{"doc":"Literal integer.","ref":"DataSpecs.Schema.Type.Literal.Integer.html","title":"DataSpecs.Schema.Type.Literal.Integer","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Literal.Integer.html#t:t/0","title":"DataSpecs.Schema.Type.Literal.Integer.t/0","type":"type"},{"doc":"Map.","ref":"DataSpecs.Schema.Type.Map.html","title":"DataSpecs.Schema.Type.Map","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Map.html#t:kv/0","title":"DataSpecs.Schema.Type.Map.kv/0","type":"type"},{"doc":"","ref":"DataSpecs.Schema.Type.Map.html#t:t/0","title":"DataSpecs.Schema.Type.Map.t/0","type":"type"},{"doc":"A map key.","ref":"DataSpecs.Schema.Type.Map.Key.html","title":"DataSpecs.Schema.Type.Map.Key","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Map.Key.html#t:t/0","title":"DataSpecs.Schema.Type.Map.Key.t/0","type":"type"},{"doc":"Range.","ref":"DataSpecs.Schema.Type.Range.html","title":"DataSpecs.Schema.Type.Range","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Range.html#t:t/0","title":"DataSpecs.Schema.Type.Range.t/0","type":"type"},{"doc":"Type reference (remote/user types).","ref":"DataSpecs.Schema.Type.Ref.html","title":"DataSpecs.Schema.Type.Ref","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Ref.html#t:t/0","title":"DataSpecs.Schema.Type.Ref.t/0","type":"type"},{"doc":"Tuple.","ref":"DataSpecs.Schema.Type.Tuple.html","title":"DataSpecs.Schema.Type.Tuple","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Tuple.html#t:cardinality/0","title":"DataSpecs.Schema.Type.Tuple.cardinality/0","type":"type"},{"doc":"","ref":"DataSpecs.Schema.Type.Tuple.html#t:t/0","title":"DataSpecs.Schema.Type.Tuple.t/0","type":"type"},{"doc":"Union.","ref":"DataSpecs.Schema.Type.Union.html","title":"DataSpecs.Schema.Type.Union","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Union.html#t:t/0","title":"DataSpecs.Schema.Type.Union.t/0","type":"type"},{"doc":"Unsupported type specs.","ref":"DataSpecs.Schema.Type.Unsupported.html","title":"DataSpecs.Schema.Type.Unsupported","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Unsupported.html#t:t/0","title":"DataSpecs.Schema.Type.Unsupported.t/0","type":"type"},{"doc":"Type variable.","ref":"DataSpecs.Schema.Type.Var.html","title":"DataSpecs.Schema.Type.Var","type":"module"},{"doc":"","ref":"DataSpecs.Schema.Type.Var.html#t:t/0","title":"DataSpecs.Schema.Type.Var.t/0","type":"type"},{"doc":"Common types.","ref":"DataSpecs.Types.html","title":"DataSpecs.Types","type":"module"},{"doc":"","ref":"DataSpecs.Types.html#t:cast_result/1","title":"DataSpecs.Types.cast_result/1","type":"type"},{"doc":"","ref":"DataSpecs.Types.html#t:custom_type_casts/0","title":"DataSpecs.Types.custom_type_casts/0","type":"type"},{"doc":"","ref":"DataSpecs.Types.html#t:mt/0","title":"DataSpecs.Types.mt/0","type":"type"},{"doc":"","ref":"DataSpecs.Types.html#t:mta/0","title":"DataSpecs.Types.mta/0","type":"type"},{"doc":"","ref":"DataSpecs.Types.html#t:reason/0","title":"DataSpecs.Types.reason/0","type":"type"},{"doc":"","ref":"DataSpecs.Types.html#t:type_cast_fun/0","title":"DataSpecs.Types.type_cast_fun/0","type":"type"},{"doc":"","ref":"DataSpecs.Types.html#t:type_id/0","title":"DataSpecs.Types.type_id/0","type":"type"},{"doc":"","ref":"DataSpecs.Types.html#t:value/0","title":"DataSpecs.Types.value/0","type":"type"},{"doc":"Dump a type schema. mix dataspecs . schema . dump MyModule","ref":"Mix.Tasks.Dataspecs.Schema.Dump.html","title":"Mix.Tasks.Dataspecs.Schema.Dump","type":"task"},{"doc":"Typespec based data cast and validator (inspired by forma ). DataSpecs cast elixir data into a more structured form by trying to map it to conform to a typespec . It support the following typespec specifications: basic types literal types built-in types range types union types parametrized types map (and elixir struct) types remote types user defined types The main use cases are about elixir data validatation against a typespec or interfacing with external data sources that provide you data as JSON or MessagePack, but that you wish to validate and transform into either proper structs or richer data types without a native JSON representation (such as dates or sets).","ref":"readme.html","title":"DataSpecs","type":"extras"},{"doc":"Given the following Person struct specification defmodule Person do use DataSpecs @enforce_keys [ :name , :surname ] defstruct @enforce_keys ++ [ :gender , :address , :birth_date ] @type t :: % __MODULE__ { name : String . t ( ) , surname : String . t ( ) , gender : option ( :male | :female | :other ) , address : option ( [ Address . t ( ) , ... ] ) , birth_date : option ( Date . t ( ) ) } @type option ( x ) :: nil | x end defmodule Address do @enforce_keys [ :streetname , :streenumber , :postcode , :town ] defstruct @enforce_keys @type t :: % __MODULE__ { streetname : String . t ( ) , streenumber : String . t ( ) , postcode : String . t ( ) , town : String . t ( ) } end we can cast a JSON object encoding an instance of a Person with: ~s/{ &quot;name&quot;: &quot;Joe&quot;, &quot;surname&quot;: &quot;Smith&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;birth_date&quot;: &quot;1980-12-31&quot;, &quot;address&quot;: [{ &quot;streetname&quot;: &quot;High Street&quot;, &quot;streenumber&quot;: &quot;3a&quot;, &quot;postcode&quot;: &quot;SO31 4NG&quot;, &quot;town&quot;: &quot;Hedge End, Southampton&quot; }] }/ |&gt; Jason . decode! ( ) |&gt; Person . cast ( ) # =&gt; %Person{ # address: [ # %Address{ # postcode: &quot;SO31 4NG&quot;, # streenumber: &quot;3a&quot;, # streetname: &quot;High Street&quot;, # town: &quot;Hedge End, Southampton&quot; # } # ], # birth_date: ~D[1980-12-31], # gender: :male, # name: &quot;Joe&quot;, # surname: &quot;Smith&quot; # } DataSpecs tries to figure out how to translate its input to an elixir datatype using the typespec as &quot;type schema&quot;. Scalar types (such as booleans, integers, etc.) and some composite types (such as lists, plain maps), can be simply mapped one to one after validation without any additional transformation. However, not all Elixir types have natural representations in JSON-like data (for example atoms and dates) or don't want to expose their internals (opaque types). Refer to the library test suite for more examples.","ref":"readme.html#usage","title":"DataSpecs - Usage","type":"extras"},{"doc":"def deps do [ { :dataspecs , &quot;~&gt; xxx&quot; } ] end Typespecs should be included in the compiled ebin. Set the :strip_beams option to false when compiling your project with mix release or mix escript. def project do [ app : :my_app , deps : deps ( ) , releases : [ my_app : [ strip_beams : false ] ] , ... ] end def project do [ app : :my_script , deps : deps ( ) , escript : [ strip_beams : false , ... ] , ... ] end","ref":"readme.html#installation","title":"DataSpecs - Installation","type":"extras"},{"doc":"Builtin For reference, check the cast available under DataSpecs.Cast.Builtin and DataSpecs.Cast.Extra . The modules DataSpecs.Cast.Extra provides pre-defined custom type cast for: DateTime.t/0 : cast iso datetime strings (ie: 2001-12-31 06:54:02Z -&gt; ~U[2001-12-31 06:54:02Z] ) Date.t/0 : cast iso date strings (ie: 2001-12-31 -&gt; ~D[2022-06-03] ) MapSet.t/1 : cast lists of T into a MapSet.t(T) (ie: [1, 2] -&gt; #MapSet&lt;[1, 2]&gt; ) Custom You can pass custom type casts along as an optional argument to the DataSpecs.cast/4 function. The type of the custom cast function is @type custom_type_cast_fun :: ( value ( ) , custom_type_casts ( ) , [ type_cast_fun ( ) ] -&gt; value ( ) ) for example a custom MapSet.t/1 cast could be implement as: def custom_mapset_cast ( value , custom_type_casts , [ type_cast_fun ] ) do case Enumerable . impl_for ( value ) do nil -&gt; { :error , [ &quot;can&#39;t convert \#{ inspect ( value ) } to a MapSet.t/1, value not enumerable&quot; ] } _ -&gt; value |&gt; Enum . to_list ( ) |&gt; DataSpecs.Cast.Builtin . list ( custom_type_casts , [ type_cast_fun ] ) |&gt; case do { :ok , casted_value } -&gt; { :ok , MapSet . new ( casted_value ) } { :error , errors } -&gt; { :error , [ &quot;can&#39;t convert \#{ inspect ( value ) } to a MapSet.t/1&quot; , errors ] } end end end The custom cast take the input value, check it's enumerable and then builds a MapSet over the items of the input value. It takes as argument a list of DataSpecs.Types.type_cast_fun/0 associated with the type parameters. For example, let's say we have: @type my_set_of_integer :: MapSet . t ( integer ( ) ) and an input value: 1 .. 10 then the custom type cast function will be called with custom_mapset_cast ( 1 .. 10 , custom_type_casts , [ &amp; DataSpecs.Cast.Builtin . integer / 3 ] )","ref":"readme.html#type-cast","title":"DataSpecs - Type cast","type":"extras"},{"doc":"Custom validation rules can be defined with a custom type cast. For example let's say than we want to validate a field of type string to be in upcase form: defmodule AStruct do use DataSpecs @enforce_keys [ :field ] defstruct @enforce_keys @type t :: % __MODULE__ { field : upcase_string ( ) } @type upcase_string :: String . t ( ) def custom_field_cast ( value , custom_type_casts , type_params_casts ) do with { :ok , value } &lt;- DataSpecs.Cast.Builtin . binary ( value , custom_type_casts , type_params_casts ) ^ name &lt;- String . upcase ( name ) do { :ok , name } else { :error , errors } -&gt; { :error , [ &quot; \#{ inspect ( value ) } is not an upcase string&quot; , errors ] } false -&gt; { :error , [ &quot; \#{ inspect ( value ) } is not an upcase string&quot; ] } end end end custom_type_casts = %{ { AStruct , :upcase_string , 0 } =&gt; &amp; AStruct . custom_field_cast / 3 } AStruct . cast ( %{ field : &quot;AAA&quot; } , custom_type_casts ) # =&gt; %AStruct{field: &quot;AAA&quot;}","ref":"readme.html#validators","title":"DataSpecs - Validators","type":"extras"},{"doc":"The following types coercion are implicitly applied: float() integer() -&gt; float() Example: # --- 1 # to 1.0 tuple() list() -&gt; tuple() @type t :: { atom ( ) , integer ( ) } # --- [ :a , 1 ] # to { :a , 1 } struct() map() -&gt; struct() Example: defmodule AStruct do defstruct [ :a , :b ] @type t :: % __MODULE__ { a : nil | binary ( ) , b : nil | binary ( ) } # --- %{ a : &quot;1&quot; , b : &quot;2&quot; } # to % AStruct { a : &quot;1&quot; , b : &quot;2&quot; } map / struct keys map / struct binary() keys -&gt; existing atom() Example: @type a_map :: %{ a : binary , b : binary } # --- %{ &quot;a&quot; =&gt; &quot;1&quot; , &quot;b&quot; =&gt; &quot;2&quot; } # to %{ a : &quot;1&quot; , b : &quot;2&quot; } atom() binary() -&gt; existing atom() Example: # --- &quot;bin&quot; # to :bin","ref":"readme.html#type-coercion","title":"DataSpecs - Type coercion","type":"extras"},{"doc":"DataSpecs.Plug.Cast provides a plug to &quot;Jason.decode! -&gt; DataSpecs.cast&quot; in your routes: defmodule Api.Router.Something do use Plug.Router import DataSpecs.Plug.Cast , only : [ typeref : 2 , value : 1 ] plug :match plug DataSpecs.Plug.Cast plug :dispatch post &quot;/foo&quot; , typeref ( Api.Model.Foo , :t ) do % Api.Model.Foo { ... } = value ( conn ) ... end end","ref":"readme.html#plug","title":"DataSpecs - Plug","type":"extras"},{"doc":"https://github.com/visciang/example_validation","ref":"readme.html#ecto-embedded-schema-validation-comparison","title":"DataSpecs - Ecto embedded schema validation comparison","type":"extras"}]